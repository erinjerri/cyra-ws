"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uint8array-extras@1.4.0";
exports.ids = ["vendor-chunks/uint8array-extras@1.4.0"];
exports.modules = {

/***/ "(rsc)/../../../../node_modules/.pnpm/uint8array-extras@1.4.0/node_modules/uint8array-extras/index.js":
/*!******************************************************************************************************!*\
  !*** ../../../../node_modules/.pnpm/uint8array-extras@1.4.0/node_modules/uint8array-extras/index.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areUint8ArraysEqual: () => (/* binding */ areUint8ArraysEqual),\n/* harmony export */   assertUint8Array: () => (/* binding */ assertUint8Array),\n/* harmony export */   assertUint8ArrayOrArrayBuffer: () => (/* binding */ assertUint8ArrayOrArrayBuffer),\n/* harmony export */   base64ToString: () => (/* binding */ base64ToString),\n/* harmony export */   base64ToUint8Array: () => (/* binding */ base64ToUint8Array),\n/* harmony export */   compareUint8Arrays: () => (/* binding */ compareUint8Arrays),\n/* harmony export */   concatUint8Arrays: () => (/* binding */ concatUint8Arrays),\n/* harmony export */   getUintBE: () => (/* binding */ getUintBE),\n/* harmony export */   hexToUint8Array: () => (/* binding */ hexToUint8Array),\n/* harmony export */   includes: () => (/* binding */ includes),\n/* harmony export */   indexOf: () => (/* binding */ indexOf),\n/* harmony export */   isUint8Array: () => (/* binding */ isUint8Array),\n/* harmony export */   stringToBase64: () => (/* binding */ stringToBase64),\n/* harmony export */   stringToUint8Array: () => (/* binding */ stringToUint8Array),\n/* harmony export */   toUint8Array: () => (/* binding */ toUint8Array),\n/* harmony export */   uint8ArrayToBase64: () => (/* binding */ uint8ArrayToBase64),\n/* harmony export */   uint8ArrayToHex: () => (/* binding */ uint8ArrayToHex),\n/* harmony export */   uint8ArrayToString: () => (/* binding */ uint8ArrayToString)\n/* harmony export */ });\nconst objectToString = Object.prototype.toString;\nconst uint8ArrayStringified = '[object Uint8Array]';\nconst arrayBufferStringified = '[object ArrayBuffer]';\n\nfunction isType(value, typeConstructor, typeStringified) {\n\tif (!value) {\n\t\treturn false;\n\t}\n\n\tif (value.constructor === typeConstructor) {\n\t\treturn true;\n\t}\n\n\treturn objectToString.call(value) === typeStringified;\n}\n\nfunction isUint8Array(value) {\n\treturn isType(value, Uint8Array, uint8ArrayStringified);\n}\n\nfunction isArrayBuffer(value) {\n\treturn isType(value, ArrayBuffer, arrayBufferStringified);\n}\n\nfunction isUint8ArrayOrArrayBuffer(value) {\n\treturn isUint8Array(value) || isArrayBuffer(value);\n}\n\nfunction assertUint8Array(value) {\n\tif (!isUint8Array(value)) {\n\t\tthrow new TypeError(`Expected \\`Uint8Array\\`, got \\`${typeof value}\\``);\n\t}\n}\n\nfunction assertUint8ArrayOrArrayBuffer(value) {\n\tif (!isUint8ArrayOrArrayBuffer(value)) {\n\t\tthrow new TypeError(`Expected \\`Uint8Array\\` or \\`ArrayBuffer\\`, got \\`${typeof value}\\``);\n\t}\n}\n\nfunction toUint8Array(value) {\n\tif (value instanceof ArrayBuffer) {\n\t\treturn new Uint8Array(value);\n\t}\n\n\tif (ArrayBuffer.isView(value)) {\n\t\treturn new Uint8Array(value.buffer, value.byteOffset, value.byteLength);\n\t}\n\n\tthrow new TypeError(`Unsupported value, got \\`${typeof value}\\`.`);\n}\n\nfunction concatUint8Arrays(arrays, totalLength) {\n\tif (arrays.length === 0) {\n\t\treturn new Uint8Array(0);\n\t}\n\n\ttotalLength ??= arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0);\n\n\tconst returnValue = new Uint8Array(totalLength);\n\n\tlet offset = 0;\n\tfor (const array of arrays) {\n\t\tassertUint8Array(array);\n\t\treturnValue.set(array, offset);\n\t\toffset += array.length;\n\t}\n\n\treturn returnValue;\n}\n\nfunction areUint8ArraysEqual(a, b) {\n\tassertUint8Array(a);\n\tassertUint8Array(b);\n\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\t// eslint-disable-next-line unicorn/no-for-loop\n\tfor (let index = 0; index < a.length; index++) {\n\t\tif (a[index] !== b[index]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction compareUint8Arrays(a, b) {\n\tassertUint8Array(a);\n\tassertUint8Array(b);\n\n\tconst length = Math.min(a.length, b.length);\n\n\tfor (let index = 0; index < length; index++) {\n\t\tconst diff = a[index] - b[index];\n\t\tif (diff !== 0) {\n\t\t\treturn Math.sign(diff);\n\t\t}\n\t}\n\n\t// At this point, all the compared elements are equal.\n\t// The shorter array should come first if the arrays are of different lengths.\n\treturn Math.sign(a.length - b.length);\n}\n\nconst cachedDecoders = {\n\tutf8: new globalThis.TextDecoder('utf8'),\n};\n\nfunction uint8ArrayToString(array, encoding = 'utf8') {\n\tassertUint8ArrayOrArrayBuffer(array);\n\tcachedDecoders[encoding] ??= new globalThis.TextDecoder(encoding);\n\treturn cachedDecoders[encoding].decode(array);\n}\n\nfunction assertString(value) {\n\tif (typeof value !== 'string') {\n\t\tthrow new TypeError(`Expected \\`string\\`, got \\`${typeof value}\\``);\n\t}\n}\n\nconst cachedEncoder = new globalThis.TextEncoder();\n\nfunction stringToUint8Array(string) {\n\tassertString(string);\n\treturn cachedEncoder.encode(string);\n}\n\nfunction base64ToBase64Url(base64) {\n\treturn base64.replaceAll('+', '-').replaceAll('/', '_').replace(/=+$/, '');\n}\n\nfunction base64UrlToBase64(base64url) {\n\treturn base64url.replaceAll('-', '+').replaceAll('_', '/');\n}\n\n// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/\nconst MAX_BLOCK_SIZE = 65_535;\n\nfunction uint8ArrayToBase64(array, {urlSafe = false} = {}) {\n\tassertUint8Array(array);\n\n\tlet base64;\n\n\tif (array.length < MAX_BLOCK_SIZE) {\n\t// Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n\t\tbase64 = globalThis.btoa(String.fromCodePoint.apply(this, array));\n\t} else {\n\t\tbase64 = '';\n\t\tfor (const value of array) {\n\t\t\tbase64 += String.fromCodePoint(value);\n\t\t}\n\n\t\tbase64 = globalThis.btoa(base64);\n\t}\n\n\treturn urlSafe ? base64ToBase64Url(base64) : base64;\n}\n\nfunction base64ToUint8Array(base64String) {\n\tassertString(base64String);\n\treturn Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), x => x.codePointAt(0));\n}\n\nfunction stringToBase64(string, {urlSafe = false} = {}) {\n\tassertString(string);\n\treturn uint8ArrayToBase64(stringToUint8Array(string), {urlSafe});\n}\n\nfunction base64ToString(base64String) {\n\tassertString(base64String);\n\treturn uint8ArrayToString(base64ToUint8Array(base64String));\n}\n\nconst byteToHexLookupTable = Array.from({length: 256}, (_, index) => index.toString(16).padStart(2, '0'));\n\nfunction uint8ArrayToHex(array) {\n\tassertUint8Array(array);\n\n\t// Concatenating a string is faster than using an array.\n\tlet hexString = '';\n\n\t// eslint-disable-next-line unicorn/no-for-loop -- Max performance is critical.\n\tfor (let index = 0; index < array.length; index++) {\n\t\thexString += byteToHexLookupTable[array[index]];\n\t}\n\n\treturn hexString;\n}\n\nconst hexToDecimalLookupTable = {\n\t0: 0,\n\t1: 1,\n\t2: 2,\n\t3: 3,\n\t4: 4,\n\t5: 5,\n\t6: 6,\n\t7: 7,\n\t8: 8,\n\t9: 9,\n\ta: 10,\n\tb: 11,\n\tc: 12,\n\td: 13,\n\te: 14,\n\tf: 15,\n\tA: 10,\n\tB: 11,\n\tC: 12,\n\tD: 13,\n\tE: 14,\n\tF: 15,\n};\n\nfunction hexToUint8Array(hexString) {\n\tassertString(hexString);\n\n\tif (hexString.length % 2 !== 0) {\n\t\tthrow new Error('Invalid Hex string length.');\n\t}\n\n\tconst resultLength = hexString.length / 2;\n\tconst bytes = new Uint8Array(resultLength);\n\n\tfor (let index = 0; index < resultLength; index++) {\n\t\tconst highNibble = hexToDecimalLookupTable[hexString[index * 2]];\n\t\tconst lowNibble = hexToDecimalLookupTable[hexString[(index * 2) + 1]];\n\n\t\tif (highNibble === undefined || lowNibble === undefined) {\n\t\t\tthrow new Error(`Invalid Hex character encountered at position ${index * 2}`);\n\t\t}\n\n\t\tbytes[index] = (highNibble << 4) | lowNibble; // eslint-disable-line no-bitwise\n\t}\n\n\treturn bytes;\n}\n\n/**\n@param {DataView} view\n@returns {number}\n*/\nfunction getUintBE(view) {\n\tconst {byteLength} = view;\n\n\tif (byteLength === 6) {\n\t\treturn (view.getUint16(0) * (2 ** 32)) + view.getUint32(2);\n\t}\n\n\tif (byteLength === 5) {\n\t\treturn (view.getUint8(0) * (2 ** 32)) + view.getUint32(1);\n\t}\n\n\tif (byteLength === 4) {\n\t\treturn view.getUint32(0);\n\t}\n\n\tif (byteLength === 3) {\n\t\treturn (view.getUint8(0) * (2 ** 16)) + view.getUint16(1);\n\t}\n\n\tif (byteLength === 2) {\n\t\treturn view.getUint16(0);\n\t}\n\n\tif (byteLength === 1) {\n\t\treturn view.getUint8(0);\n\t}\n}\n\n/**\n@param {Uint8Array} array\n@param {Uint8Array} value\n@returns {number}\n*/\nfunction indexOf(array, value) {\n\tconst arrayLength = array.length;\n\tconst valueLength = value.length;\n\n\tif (valueLength === 0) {\n\t\treturn -1;\n\t}\n\n\tif (valueLength > arrayLength) {\n\t\treturn -1;\n\t}\n\n\tconst validOffsetLength = arrayLength - valueLength;\n\n\tfor (let index = 0; index <= validOffsetLength; index++) {\n\t\tlet isMatch = true;\n\t\tfor (let index2 = 0; index2 < valueLength; index2++) {\n\t\t\tif (array[index + index2] !== value[index2]) {\n\t\t\t\tisMatch = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (isMatch) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n@param {Uint8Array} array\n@param {Uint8Array} value\n@returns {boolean}\n*/\nfunction includes(array, value) {\n\treturn indexOf(array, value) !== -1;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VpbnQ4YXJyYXktZXh0cmFzQDEuNC4wL25vZGVfbW9kdWxlcy91aW50OGFycmF5LWV4dHJhcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLHdEQUF3RCxhQUFhO0FBQ3JFO0FBQ0E7O0FBRU87QUFDUDtBQUNBLDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhO0FBQzlEOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPLG9DQUFvQyxpQkFBaUIsSUFBSTtBQUNoRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPLGlDQUFpQyxpQkFBaUIsSUFBSTtBQUM3RDtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxZQUFZOztBQUU5QztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UsVUFBVTtBQUM5RTs7QUFFQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsVUFBVTtBQUNsQixVQUFVO0FBQ1Y7QUFDTztBQUNQLFFBQVEsWUFBWTs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsWUFBWTtBQUNwQixRQUFRLFlBQVk7QUFDcEIsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCLFFBQVEsWUFBWTtBQUNwQixVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lcmluamVycmkvbm9kZV9tb2R1bGVzLy5wbnBtL3VpbnQ4YXJyYXktZXh0cmFzQDEuNC4wL25vZGVfbW9kdWxlcy91aW50OGFycmF5LWV4dHJhcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB1aW50OEFycmF5U3RyaW5naWZpZWQgPSAnW29iamVjdCBVaW50OEFycmF5XSc7XG5jb25zdCBhcnJheUJ1ZmZlclN0cmluZ2lmaWVkID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcblxuZnVuY3Rpb24gaXNUeXBlKHZhbHVlLCB0eXBlQ29uc3RydWN0b3IsIHR5cGVTdHJpbmdpZmllZCkge1xuXHRpZiAoIXZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSB0eXBlQ29uc3RydWN0b3IpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gdHlwZVN0cmluZ2lmaWVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG5cdHJldHVybiBpc1R5cGUodmFsdWUsIFVpbnQ4QXJyYXksIHVpbnQ4QXJyYXlTdHJpbmdpZmllZCk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcblx0cmV0dXJuIGlzVHlwZSh2YWx1ZSwgQXJyYXlCdWZmZXIsIGFycmF5QnVmZmVyU3RyaW5naWZpZWQpO1xufVxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXlPckFycmF5QnVmZmVyKHZhbHVlKSB7XG5cdHJldHVybiBpc1VpbnQ4QXJyYXkodmFsdWUpIHx8IGlzQXJyYXlCdWZmZXIodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VWludDhBcnJheSh2YWx1ZSkge1xuXHRpZiAoIWlzVWludDhBcnJheSh2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBVaW50OEFycmF5XFxgLCBnb3QgXFxgJHt0eXBlb2YgdmFsdWV9XFxgYCk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFVpbnQ4QXJyYXlPckFycmF5QnVmZmVyKHZhbHVlKSB7XG5cdGlmICghaXNVaW50OEFycmF5T3JBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBVaW50OEFycmF5XFxgIG9yIFxcYEFycmF5QnVmZmVyXFxgLCBnb3QgXFxgJHt0eXBlb2YgdmFsdWV9XFxgYCk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvVWludDhBcnJheSh2YWx1ZSkge1xuXHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHRcdHJldHVybiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG5cdH1cblxuXHRpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuXHRcdHJldHVybiBuZXcgVWludDhBcnJheSh2YWx1ZS5idWZmZXIsIHZhbHVlLmJ5dGVPZmZzZXQsIHZhbHVlLmJ5dGVMZW5ndGgpO1xuXHR9XG5cblx0dGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdmFsdWUsIGdvdCBcXGAke3R5cGVvZiB2YWx1ZX1cXGAuYCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRVaW50OEFycmF5cyhhcnJheXMsIHRvdGFsTGVuZ3RoKSB7XG5cdGlmIChhcnJheXMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuXHR9XG5cblx0dG90YWxMZW5ndGggPz89IGFycmF5cy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlLmxlbmd0aCwgMCk7XG5cblx0Y29uc3QgcmV0dXJuVmFsdWUgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cblx0bGV0IG9mZnNldCA9IDA7XG5cdGZvciAoY29uc3QgYXJyYXkgb2YgYXJyYXlzKSB7XG5cdFx0YXNzZXJ0VWludDhBcnJheShhcnJheSk7XG5cdFx0cmV0dXJuVmFsdWUuc2V0KGFycmF5LCBvZmZzZXQpO1xuXHRcdG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG5cdH1cblxuXHRyZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmVVaW50OEFycmF5c0VxdWFsKGEsIGIpIHtcblx0YXNzZXJ0VWludDhBcnJheShhKTtcblx0YXNzZXJ0VWludDhBcnJheShiKTtcblxuXHRpZiAoYSA9PT0gYikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWZvci1sb29wXG5cdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdGlmIChhW2luZGV4XSAhPT0gYltpbmRleF0pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVVaW50OEFycmF5cyhhLCBiKSB7XG5cdGFzc2VydFVpbnQ4QXJyYXkoYSk7XG5cdGFzc2VydFVpbnQ4QXJyYXkoYik7XG5cblx0Y29uc3QgbGVuZ3RoID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcblxuXHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0Y29uc3QgZGlmZiA9IGFbaW5kZXhdIC0gYltpbmRleF07XG5cdFx0aWYgKGRpZmYgIT09IDApIHtcblx0XHRcdHJldHVybiBNYXRoLnNpZ24oZGlmZik7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQXQgdGhpcyBwb2ludCwgYWxsIHRoZSBjb21wYXJlZCBlbGVtZW50cyBhcmUgZXF1YWwuXG5cdC8vIFRoZSBzaG9ydGVyIGFycmF5IHNob3VsZCBjb21lIGZpcnN0IGlmIHRoZSBhcnJheXMgYXJlIG9mIGRpZmZlcmVudCBsZW5ndGhzLlxuXHRyZXR1cm4gTWF0aC5zaWduKGEubGVuZ3RoIC0gYi5sZW5ndGgpO1xufVxuXG5jb25zdCBjYWNoZWREZWNvZGVycyA9IHtcblx0dXRmODogbmV3IGdsb2JhbFRoaXMuVGV4dERlY29kZXIoJ3V0ZjgnKSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1aW50OEFycmF5VG9TdHJpbmcoYXJyYXksIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG5cdGFzc2VydFVpbnQ4QXJyYXlPckFycmF5QnVmZmVyKGFycmF5KTtcblx0Y2FjaGVkRGVjb2RlcnNbZW5jb2RpbmddID8/PSBuZXcgZ2xvYmFsVGhpcy5UZXh0RGVjb2RlcihlbmNvZGluZyk7XG5cdHJldHVybiBjYWNoZWREZWNvZGVyc1tlbmNvZGluZ10uZGVjb2RlKGFycmF5KTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgc3RyaW5nXFxgLCBnb3QgXFxgJHt0eXBlb2YgdmFsdWV9XFxgYCk7XG5cdH1cbn1cblxuY29uc3QgY2FjaGVkRW5jb2RlciA9IG5ldyBnbG9iYWxUaGlzLlRleHRFbmNvZGVyKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb1VpbnQ4QXJyYXkoc3RyaW5nKSB7XG5cdGFzc2VydFN0cmluZyhzdHJpbmcpO1xuXHRyZXR1cm4gY2FjaGVkRW5jb2Rlci5lbmNvZGUoc3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CYXNlNjRVcmwoYmFzZTY0KSB7XG5cdHJldHVybiBiYXNlNjQucmVwbGFjZUFsbCgnKycsICctJykucmVwbGFjZUFsbCgnLycsICdfJykucmVwbGFjZSgvPSskLywgJycpO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRVcmxUb0Jhc2U2NChiYXNlNjR1cmwpIHtcblx0cmV0dXJuIGJhc2U2NHVybC5yZXBsYWNlQWxsKCctJywgJysnKS5yZXBsYWNlQWxsKCdfJywgJy8nKTtcbn1cblxuLy8gUmVmZXJlbmNlOiBodHRwczovL3BodW9jLm5nL2NvbGxlY3Rpb24vdGhpcy12cy10aGF0L2NvbmNhdC12cy1wdXNoL1xuY29uc3QgTUFYX0JMT0NLX1NJWkUgPSA2NV81MzU7XG5cbmV4cG9ydCBmdW5jdGlvbiB1aW50OEFycmF5VG9CYXNlNjQoYXJyYXksIHt1cmxTYWZlID0gZmFsc2V9ID0ge30pIHtcblx0YXNzZXJ0VWludDhBcnJheShhcnJheSk7XG5cblx0bGV0IGJhc2U2NDtcblxuXHRpZiAoYXJyYXkubGVuZ3RoIDwgTUFYX0JMT0NLX1NJWkUpIHtcblx0Ly8gUmVxdWlyZWQgYXMgYGJ0b2FgIGFuZCBgYXRvYmAgZG9uJ3QgcHJvcGVybHkgc3VwcG9ydCBVbmljb2RlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L0Jhc2U2NCN0aGVfdW5pY29kZV9wcm9ibGVtXG5cdFx0YmFzZTY0ID0gZ2xvYmFsVGhpcy5idG9hKFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KHRoaXMsIGFycmF5KSk7XG5cdH0gZWxzZSB7XG5cdFx0YmFzZTY0ID0gJyc7XG5cdFx0Zm9yIChjb25zdCB2YWx1ZSBvZiBhcnJheSkge1xuXHRcdFx0YmFzZTY0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHZhbHVlKTtcblx0XHR9XG5cblx0XHRiYXNlNjQgPSBnbG9iYWxUaGlzLmJ0b2EoYmFzZTY0KTtcblx0fVxuXG5cdHJldHVybiB1cmxTYWZlID8gYmFzZTY0VG9CYXNlNjRVcmwoYmFzZTY0KSA6IGJhc2U2NDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvVWludDhBcnJheShiYXNlNjRTdHJpbmcpIHtcblx0YXNzZXJ0U3RyaW5nKGJhc2U2NFN0cmluZyk7XG5cdHJldHVybiBVaW50OEFycmF5LmZyb20oZ2xvYmFsVGhpcy5hdG9iKGJhc2U2NFVybFRvQmFzZTY0KGJhc2U2NFN0cmluZykpLCB4ID0+IHguY29kZVBvaW50QXQoMCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9CYXNlNjQoc3RyaW5nLCB7dXJsU2FmZSA9IGZhbHNlfSA9IHt9KSB7XG5cdGFzc2VydFN0cmluZyhzdHJpbmcpO1xuXHRyZXR1cm4gdWludDhBcnJheVRvQmFzZTY0KHN0cmluZ1RvVWludDhBcnJheShzdHJpbmcpLCB7dXJsU2FmZX0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9TdHJpbmcoYmFzZTY0U3RyaW5nKSB7XG5cdGFzc2VydFN0cmluZyhiYXNlNjRTdHJpbmcpO1xuXHRyZXR1cm4gdWludDhBcnJheVRvU3RyaW5nKGJhc2U2NFRvVWludDhBcnJheShiYXNlNjRTdHJpbmcpKTtcbn1cblxuY29uc3QgYnl0ZVRvSGV4TG9va3VwVGFibGUgPSBBcnJheS5mcm9tKHtsZW5ndGg6IDI1Nn0sIChfLCBpbmRleCkgPT4gaW5kZXgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuXG5leHBvcnQgZnVuY3Rpb24gdWludDhBcnJheVRvSGV4KGFycmF5KSB7XG5cdGFzc2VydFVpbnQ4QXJyYXkoYXJyYXkpO1xuXG5cdC8vIENvbmNhdGVuYXRpbmcgYSBzdHJpbmcgaXMgZmFzdGVyIHRoYW4gdXNpbmcgYW4gYXJyYXkuXG5cdGxldCBoZXhTdHJpbmcgPSAnJztcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1mb3ItbG9vcCAtLSBNYXggcGVyZm9ybWFuY2UgaXMgY3JpdGljYWwuXG5cdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheS5sZW5ndGg7IGluZGV4KyspIHtcblx0XHRoZXhTdHJpbmcgKz0gYnl0ZVRvSGV4TG9va3VwVGFibGVbYXJyYXlbaW5kZXhdXTtcblx0fVxuXG5cdHJldHVybiBoZXhTdHJpbmc7XG59XG5cbmNvbnN0IGhleFRvRGVjaW1hbExvb2t1cFRhYmxlID0ge1xuXHQwOiAwLFxuXHQxOiAxLFxuXHQyOiAyLFxuXHQzOiAzLFxuXHQ0OiA0LFxuXHQ1OiA1LFxuXHQ2OiA2LFxuXHQ3OiA3LFxuXHQ4OiA4LFxuXHQ5OiA5LFxuXHRhOiAxMCxcblx0YjogMTEsXG5cdGM6IDEyLFxuXHRkOiAxMyxcblx0ZTogMTQsXG5cdGY6IDE1LFxuXHRBOiAxMCxcblx0QjogMTEsXG5cdEM6IDEyLFxuXHREOiAxMyxcblx0RTogMTQsXG5cdEY6IDE1LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvVWludDhBcnJheShoZXhTdHJpbmcpIHtcblx0YXNzZXJ0U3RyaW5nKGhleFN0cmluZyk7XG5cblx0aWYgKGhleFN0cmluZy5sZW5ndGggJSAyICE9PSAwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEhleCBzdHJpbmcgbGVuZ3RoLicpO1xuXHR9XG5cblx0Y29uc3QgcmVzdWx0TGVuZ3RoID0gaGV4U3RyaW5nLmxlbmd0aCAvIDI7XG5cdGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0TGVuZ3RoKTtcblxuXHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcmVzdWx0TGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0Y29uc3QgaGlnaE5pYmJsZSA9IGhleFRvRGVjaW1hbExvb2t1cFRhYmxlW2hleFN0cmluZ1tpbmRleCAqIDJdXTtcblx0XHRjb25zdCBsb3dOaWJibGUgPSBoZXhUb0RlY2ltYWxMb29rdXBUYWJsZVtoZXhTdHJpbmdbKGluZGV4ICogMikgKyAxXV07XG5cblx0XHRpZiAoaGlnaE5pYmJsZSA9PT0gdW5kZWZpbmVkIHx8IGxvd05pYmJsZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSGV4IGNoYXJhY3RlciBlbmNvdW50ZXJlZCBhdCBwb3NpdGlvbiAke2luZGV4ICogMn1gKTtcblx0XHR9XG5cblx0XHRieXRlc1tpbmRleF0gPSAoaGlnaE5pYmJsZSA8PCA0KSB8IGxvd05pYmJsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1iaXR3aXNlXG5cdH1cblxuXHRyZXR1cm4gYnl0ZXM7XG59XG5cbi8qKlxuQHBhcmFtIHtEYXRhVmlld30gdmlld1xuQHJldHVybnMge251bWJlcn1cbiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWludEJFKHZpZXcpIHtcblx0Y29uc3Qge2J5dGVMZW5ndGh9ID0gdmlldztcblxuXHRpZiAoYnl0ZUxlbmd0aCA9PT0gNikge1xuXHRcdHJldHVybiAodmlldy5nZXRVaW50MTYoMCkgKiAoMiAqKiAzMikpICsgdmlldy5nZXRVaW50MzIoMik7XG5cdH1cblxuXHRpZiAoYnl0ZUxlbmd0aCA9PT0gNSkge1xuXHRcdHJldHVybiAodmlldy5nZXRVaW50OCgwKSAqICgyICoqIDMyKSkgKyB2aWV3LmdldFVpbnQzMigxKTtcblx0fVxuXG5cdGlmIChieXRlTGVuZ3RoID09PSA0KSB7XG5cdFx0cmV0dXJuIHZpZXcuZ2V0VWludDMyKDApO1xuXHR9XG5cblx0aWYgKGJ5dGVMZW5ndGggPT09IDMpIHtcblx0XHRyZXR1cm4gKHZpZXcuZ2V0VWludDgoMCkgKiAoMiAqKiAxNikpICsgdmlldy5nZXRVaW50MTYoMSk7XG5cdH1cblxuXHRpZiAoYnl0ZUxlbmd0aCA9PT0gMikge1xuXHRcdHJldHVybiB2aWV3LmdldFVpbnQxNigwKTtcblx0fVxuXG5cdGlmIChieXRlTGVuZ3RoID09PSAxKSB7XG5cdFx0cmV0dXJuIHZpZXcuZ2V0VWludDgoMCk7XG5cdH1cbn1cblxuLyoqXG5AcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5XG5AcGFyYW0ge1VpbnQ4QXJyYXl9IHZhbHVlXG5AcmV0dXJucyB7bnVtYmVyfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0Y29uc3QgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cblx0aWYgKHZhbHVlTGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG5cblx0aWYgKHZhbHVlTGVuZ3RoID4gYXJyYXlMZW5ndGgpIHtcblx0XHRyZXR1cm4gLTE7XG5cdH1cblxuXHRjb25zdCB2YWxpZE9mZnNldExlbmd0aCA9IGFycmF5TGVuZ3RoIC0gdmFsdWVMZW5ndGg7XG5cblx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8PSB2YWxpZE9mZnNldExlbmd0aDsgaW5kZXgrKykge1xuXHRcdGxldCBpc01hdGNoID0gdHJ1ZTtcblx0XHRmb3IgKGxldCBpbmRleDIgPSAwOyBpbmRleDIgPCB2YWx1ZUxlbmd0aDsgaW5kZXgyKyspIHtcblx0XHRcdGlmIChhcnJheVtpbmRleCArIGluZGV4Ml0gIT09IHZhbHVlW2luZGV4Ml0pIHtcblx0XHRcdFx0aXNNYXRjaCA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNNYXRjaCkge1xuXHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAtMTtcbn1cblxuLyoqXG5AcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5XG5AcGFyYW0ge1VpbnQ4QXJyYXl9IHZhbHVlXG5AcmV0dXJucyB7Ym9vbGVhbn1cbiovXG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG5cdHJldHVybiBpbmRleE9mKGFycmF5LCB2YWx1ZSkgIT09IC0xO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../../../node_modules/.pnpm/uint8array-extras@1.4.0/node_modules/uint8array-extras/index.js\n");

/***/ })

};
;